using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Content.Shared._ES.Utility;
using Robust.Shared.Prototypes;
using Robust.Shared.Random;
using Robust.Shared.Utility;

namespace Content.Shared._ES.Masks.Masquerades;

/// <summary>
///     A full set of roles for a masquerade, at different player counts.
/// </summary>
[DataDefinition]
public sealed partial class MasqueradeRoleSet : MasqueradeKind
{
    /// <summary>
    ///     All the roles in this masquerade at given population levels, baked into something easy to use by the game.
    /// </summary>
    /// <remarks>
    ///     These will never be subtractive, all cases of that will be resolved before this is generated.
    /// </remarks>
    private List<List<MasqueradeEntry>> _bakedRoles = new();

    /// <summary>
    ///     Attempts to get a mask list for the current player count.
    /// </summary>
    /// <remarks>
    ///     While the masks are random, the order in the output list is not.
    /// </remarks>
    public override bool TryGetMasks(int playerCount, IRobustRandom rng, IPrototypeManager proto, [NotNullWhen(true)] out List<ProtoId<ESMaskPrototype>>? masks)
    {
        if (!TryGetEntriesForPop(playerCount, out var entries))
        {
            masks = null;
            return false;
        }

        masks = new(playerCount);

        foreach (var entry in entries)
        {
            masks.AddRange(entry.PickMasks(rng, proto));
        }

        var failsafe = 0;

        while (masks.Count < playerCount && failsafe < 256)
        {
            masks.AddRange(DefaultMask.PickMasks(rng, proto));
            failsafe++;
        }

        if (failsafe > 256)
            throw new Exception("A masquerade would've spun forever during selection, loudly breaking instead.");

        DebugTools.AssertEqual(masks.Count, playerCount);
        return true;
    }

    private bool TryGetEntriesForPop(int playerCount, [NotNullWhen(true)] out IReadOnlyList<MasqueradeEntry>? entries)
    {
        var index = Math.Min(playerCount - MinPlayers, _bakedRoles.Count - 1);

        if (_bakedRoles.TryGetValue(index, out var entries2))
        {
            entries = entries2;
            return true;
        }

        entries = null;
        return false;
    }

    [DataField("roles", readOnly: true, required: true)]
    private IReadOnlyDictionary<int, List<MasqueradeEntry>> _roles { get; set; }

    /// <summary>
    ///     A hashable, equatable key for a MasqueradeEntry, used to handle implementing subtraction.
    /// </summary>
    public abstract class MqKey : IEquatable<MqKey>
    {
        public static MqKey FromEntry(MasqueradeEntry entry)
        {
            return entry switch
            {
                MasqueradeEntry.DirectEntry direct => new MqKeyDirect(direct.Masks),
                MasqueradeEntry.SetEntry set => new MqKeySet(set.MaskSet),
                _ => throw new NotImplementedException(),
            };
        }

        public bool Equals(MqKey? other)
        {
            // Yea so the autogenerated record equality doesn't handle sets properly.
            // So I have to do it this way instead.
            if (other is MqKeyDirect rhs && this is MqKeyDirect lhs)
            {
                return rhs.Masks.SetEquals(lhs.Masks);
            }
            else if (other is MqKeySet rhs2 && this is MqKeySet lhs2)
            {
                return rhs2.MaskSet.Equals(lhs2.MaskSet);
            }
            else
            {
                return false;
            }
        }

        public override bool Equals(object? obj)
        {
            if (obj is null)
                return false;
            if (ReferenceEquals(this, obj))
                return true;
            if (obj.GetType() != GetType())
                return false;
            return Equals((MqKey)obj);
        }

        public override int GetHashCode()
        {
            if (this is MqKeyDirect direct)
                // Yea so. You cannot hash a set in C#.
                // Meaning we're bodging set hashes here. Yes I spent over an hour debugging this.
                // MasqueradeEntry always has to have at least one mask so this is fine.
                // Also can't use Sum because it yells if you overflow.
                return direct.Masks.Aggregate(0, (hash, entry) => unchecked(hash + entry.GetHashCode()));

            if (this is MqKeySet set)
                return HashCode.Combine(set.MaskSet);

            throw new NotImplementedException();
        }
    }

    private sealed class MqKeyDirect(IReadOnlySet<ProtoId<ESMaskPrototype>> masks) : MqKey
    {
        public IReadOnlySet<ProtoId<ESMaskPrototype>> Masks { get; } = masks;
    }

    private sealed class MqKeySet(ProtoId<ESMaskSetPrototype> maskSet) : MqKey
    {

        public ProtoId<ESMaskSetPrototype> MaskSet { get; } = maskSet;
    }

    internal override void Init()
    {
        // Validation wise, this would have better UX if all this happened at parse time so ValidationNodes could be made.
        // But doing all of this at parse time would have Consequences I don't want to deal with and would significantly
        // complicate all of this code. So for now, the asserts will have to do.
        var rollingSet = new Dictionary<MqKey, MasqueradeEntry>();

        var minPlayers = _roles.Keys.Min();
        var maxSpecifiedPlayers = _roles.Keys.Max();

        DebugTools.Assert(minPlayers > 0, "You can't have any roles without players, minPlayers must be at least 1.");
        DebugTools.Assert(minPlayers == MinPlayers, $"Minimum players should match the first specified set of entries (expected {MinPlayers}, found {minPlayers})");

        var lastAt = minPlayers;

        foreach (var popCount in _roles.Keys.Order())
        {
            // Catch up any that weren't in the list by copying them.
            for (var i = lastAt; i < popCount - 1; i++)
            {
                // Don't actually clone, this is all immutable anyway.
                _bakedRoles.Add(_bakedRoles[^1]);
            }

            DebugTools.AssertEqual(_bakedRoles.Count, popCount - minPlayers);

            DebugTools.AssertEqual(
                _roles[popCount].Select(MqKey.FromEntry).ToHashSet().Count,
                _roles[popCount].Count,
                $"The roles list at {popCount} contains duplicate entries."
            );

            foreach (var entry in _roles[popCount])
            {
                rollingSet.MergeValue(MqKey.FromEntry(entry), entry);
            }

            foreach (var entry in rollingSet)
            {
                DebugTools.Assert(entry.Value.Subtract == false, $"You subtracted too much at {popCount} with the entry {entry}.");
            }

            _bakedRoles.Add(rollingSet.Values.Select(x => x with {}).ToList());

            DebugTools.Assert(rollingSet.Values.Sum(x => x.Count) <= popCount);

            lastAt = popCount;
        }

        // Go back through and assert that the numbers make sense, don't want any funny business with by-ref again.
        for (var popCount = minPlayers; popCount < maxSpecifiedPlayers; popCount++)
        {
            var entry = _bakedRoles[popCount - minPlayers];
            DebugTools.Assert(entry.Sum(x => x.Count) <= popCount);
        }

        DebugTools.AssertEqual(_bakedRoles.Count, _roles.Keys.Max() - minPlayers + 1, "Role baking didn't output the right number of entries.");
    }
}
